---
layout: default
title: SenseiDB - Overview
name: overview
---
<div class="hero-unit">
	<p>
		<h2>Introduction</h2>
		<p>
			Sensei is a distributed data system that was built to support many product initiatives at <a href="http://www.linkedin.com">LinkedIn.com</a>, e.g. <a href="http://www.linkedin.com/signal">LinkedIn Signal</a> and the LinkedIn Homepage. It is foundation to the LinkedIn's search and data infrastructure.
		</p>
		<p>
			Sensei is both a search engine and a database. Sensei is designed to query and navigate through documents with parts that contain text and are unstructured, as well as parts containing meta information that have well-formed structures.
		</p>
	</p>
	
	<p><a class="btn primary large" href="data-guarantee.html">Learn more &raquo;</a>
	
</div>
<h2>If you know RDBMS</h2>
<p>
  A good start to understand Sensei is by comparing it to traditional RDBMSs'. This provides a quick reference point to the common feature-sets as well as the differences. 
</p>
<p>
<h3>Query Language</h3>
<div class="row">
  <div class="span8 well">
     <h4>RDBMS</h4>
     <p>SQL is the de-facto way for querying in the RDBMS world.</p>
  </div>
  <div class="span8 well">
     <h4>Sensei</h4>
     <p> In the Sensei world, the query language is <a href="bql.html">BQL</a>, which is a SQL-variant that exposes the Sensei specific functionalities.</p>
  </div>
</div>


<p>
<h3>Interface with data in a program</h3>
<div class="row">
<div class="span8 well">
     <h4>RDBMS</h4>
     <p>To interface with your data programmatically, the JDBC API is foundation to most Java based frameworks.</p>
  </div>
  <div class="span8 well">
     <h4>Sensei</h4>
     <p>With Sensei, we offer a variety of client libraries, e.g. Java, Python etc. over a JSON/Http Rest api. Click <a href="clients.html">here</a> for details.</p>
  </div>
 </div>
</p>

<p>
<h3>Creating a table/store</h3>
<div class="row">
<div class="span8 well">
     <h4>RDBMS</h4>
     <p><code>CREATE TABLE</code> SQL statement is issued to RDBMS</p>
  </div>
  <div class="span8 well">
     <h4>Sensei</h4>
     <p>A Sensei schema is defined in the schema.xml in the configuration file. See <a href="https://github.com/linkedin/sensei/blob/master/example/cars/conf/schema.xml">example</a>.</p>
  </div>
 </div>
</p>


<p>
<h3>Data population</h3>
<div class="row">
<div class="span8 well">
     <h4>RDBMS</h4>
     <p>Data are pushed into RDBMS via <code>INSERT</code>, <code>DELETE</code> and <code>UPDATE</code> SQL commands</p>
  </div>
  <div class="span8 well">
     <h4>Sensei</h4>
     <p>Data are pulled into Sensei via <code>Gateways</code>, which defines a flowing stream of data events. See <a href="indexing-gateway.html">details</a></p>
  </div>
 </div>
</p>

	<p>
		<h2>Architecture Diagram</h2>
		<p>
			<img border="1" src="images/sensei-architect.png">
		</p>
	</p>
	<hr/>
	<p>
		<h2>Design considerations</h2>
		<p>
		<ul>
			<li>data:
				<ul>
					<li>Fault tolerance/Availability - when one replication is down, data is still accessible via other replicas</li>
					<li>Durability - N copies of data is stored so you have N backups</li>
					<li>Through-put - Parallelizable request-handling on different nodes/data replicas, designed to handle web-scale traffic</li>
					<li>Consistency - Eventual consistent, your data replicas will never go outta wack!</li>
					<li>Data recovery - each shared/replica is noted with a watermark for data recovery</li>
					<li>Large dataset - designed to handle 100s millions - billions of rows</li>
				</ul>
			</li>
			<li>horizontally scalable:
				<ul>
					<li>Data is partitioned - so work-load is also distributed</li>
					<li>Elasticity - Nodes can be added to accommodate data growth</li>
					<li>Online expansion - Cluster can grow while handling online requests</li>
					<li>Online cluster management - Cluster topology can change while handling online requests</li>
					<li>Low operational/maintenance costs - Push it, leave it and forget it.</li>
				</ul>
			</li>
			<li>performance:
				<ul>
					<li>low indexing latency - real-time update supported, e.g. when data are added to the system, they become part of the query-able corpus right away.</li>
					<li>low search latency - millisecond query response time</li>
					<li>low volatility - low variance in both indexing and search latency</li>
				</ul>
			</li>
			<li>customizability:
				<ul>
					<li>plug-in framework - custom query handling logic</li>
					<li>routing factory - custom routing logic, default: round-robin</li>
					<li>index sharding strategy - different sharding strategy for different applications, e.g. time, mod etc.</li>
					<li>relevance model</li>
				</ul>
			</li>
		</ul>
		</p>
	</p>
