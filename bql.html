---
layout: default
title: SenseiDB - BQL
---
<div class="hero-unit">
  <h2>Browse Query Language (BQL)</h2>
  <p>The query lanaguage for Sensei</p>
</div>

<h2>What is BQL?</h2>

<p>BQL stands for <span class="emphasis"><em>Browsing Query
Language</em></span>.  It is an SQL-like language that provides Sensei
users easy access to the database if they have experience using
traditional relational databases.</p>

<p>BQL was originally proposed as a query language for <a class="link"
href="http://sna-projects.com/bobo/">Bobo</a>.  Now it is being
developed and bundled with Sensei, and used by both Sensei and Sin.</p>

<h2>BNF Grammar for BQL</h2>

<h3>BNF Notation</h3>

<p>We use a modified BNF notation to describe BQL.  The following table
lists the meaning of all the meta-symbols we use.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
  <colgroup><col align="left"><col align="left"></colgroup>
  <thead>
    <tr><th align="left">Symbol</th><th align="left">Meaning</th></tr>
  </thead>
  <tbody>
    <tr><td align="left">|</td><td align="left">Or.  Choose one of the items.</td></tr>
    <tr><td align="left">[ ]</td><td align="left">Enclose optional items.</td></tr>
    <tr><td align="left">*</td><td align="left">Flags items that can be repeated 0 or more times.</td></tr>
    <tr><td align="left">( )</td><td align="left">Group items so that they can be marked with one of the symbols: [ ], |, or *.</td></tr>
  </tbody>
</table>

<h3>BQL Grammar</h3>

<p>Below is an overview of the BQL grammar in BNF.  Detailed
documentation of statements and clauses can be found in later
sections.</p>

<pre class="programlisting">
&lt;statement&gt; ::= ( &lt;select_stmt&gt; | &lt;describe_stmt&gt; ) [';']

&lt;select_stmt&gt; ::= SELECT &lt;select_list&gt; [&lt;from_clause&gt;] [&lt;where_clause&gt;] [&lt;given_clause&gt;]
                  [&lt;additional_clauses&gt;]

&lt;describe_stmt&gt; ::= ( DESC | DESCRIBE ) [&lt;index_name&gt;]

&lt;select_list&gt; ::= '*' | &lt;column_name_list&gt;

&lt;column_name_list&gt; ::= &lt;column_name&gt; ( ',' &lt;column_name&gt; )*

&lt;from_clause&gt; ::= FROM &lt;index_name&gt;

&lt;where_clause&gt; ::= WHERE &lt;search_expr&gt;

&lt;search_expr&gt; ::= &lt;boolean_expression&gt;

&lt;boolean_expression&gt; ::= &lt;boolean_term&gt; ( OR &lt;boolean_term&gt; )*

&lt;boolean_term&gt; ::= &lt;boolean_term&gt; (AND &lt;boolean_term&gt; )*

&lt;boolean_factor&gt; ::= &lt;predicate&gt;
                   | '(' &lt;boolean_expression&gt; ')'

&lt;predicate&gt; ::= &lt;in_predicate&gt;
              | &lt;contains_all_predicate&gt;
              | &lt;equal_predicate&gt;
              | &lt;not_equal_predicate&gt;
              | &lt;query_predicate&gt;
              | &lt;between_predicate&gt;
              | &lt;range_predicate&gt;
              | &lt;time_predicate&gt;
              | &lt;match_predicate&gt;
              | &lt;like_predicate&gt;

&lt;in_predicate&gt; ::= &lt;column_name&gt; [NOT] IN &lt;value_list&gt; [&lt;except_clause&gt;]
                   [&lt;predicate_props&gt;]

&lt;contains_all_predicate&gt; ::= &lt;column_name&gt; CONTAINS ALL &lt;value_list&gt; [&lt;except_clause&gt;]
                             [&lt;predicate_props&gt;]

&lt;equal_predicate&gt; ::= &lt;column_name&gt; '=' &lt;value&gt; [&lt;predicate_props&gt;]

&lt;not_equal_predicate&gt; ::= &lt;column_name&gt; '&lt;&gt;' &lt;value&gt; [&lt;predicate_props&gt;]

&lt;query_predicate&gt; ::= QUERY IS &lt;quoted_string&gt;

&lt;between_predicate&gt; ::= &lt;column_name&gt; [NOT] BETWEEN &lt;value&gt; AND &lt;value&gt;

&lt;range_predicate&gt; ::= &lt;column_name&gt; &lt;range_op&gt; &lt;value&gt;

&lt;time_predicate&gt; ::= &lt;column_name&gt; [NOT] IN LAST &lt;time_span&gt;
                   | &lt;column_name&gt; [NOT] ( SINCE | AFTER | BEFORE ) &lt;time_expr&gt;

&lt;match_predicate&gt; ::= [NOT] MATCH '(' column_name_list ')' AGAINST '(' quoted_string ')'

&lt;like_predicate&gt; ::= &lt;column_name&gt; [NOT] LIKE &lt;quoted_string&gt;

&lt;value_list&gt; ::= '(' &lt;value&gt; ( ',' &lt;value&gt; )* ')'

&lt;value&gt; ::= &lt;quoted_string&gt;
          | &lt;numeric&gt;
          | TRUE
          | FALSE

&lt;range_op&gt; ::= '&lt;' | '&lt;=' | '&gt;=' | '&gt;'

&lt;except_clause&gt; ::= EXCEPT &lt;value_list&gt;

&lt;predicate_props&gt; ::= WITH &lt;prop_list&gt;

&lt;prop_list&gt; ::= '(' &lt;key_value_pair&gt; ( ',' &lt;key_value_pair&gt; )* ')'

&lt;key_value_pair&gt; ::= &lt;quoted_string&gt; ':' &lt;quoted_string&gt;

&lt;given_clause&gt; ::= GIVEN FACET PARAM &lt;facet_param_list&gt;

&lt;facet_param_list&gt; ::= &lt;facet_param&gt; ( ',' &lt;facet_param&gt; )*

&lt;facet_param&gt; ::= '(' &lt;facet_name&gt; &lt;facet_param_name&gt; &lt;facet_param_type&gt; &lt;facet_param_value&gt; ')'

&lt;facet_param_name&gt; ::= &lt;quoted_string&gt;

&lt;facet_param_type&gt; ::= BOOLEAN | INT | LONG | STRING | BYTEARRAY | DOUBLE

&lt;facet_param_value&gt; ::= &lt;quoted_string&gt;

&lt;additional_clauses&gt; ::= ( &lt;additional_clause&gt; )+

&lt;additional_clause&gt; ::= &lt;order_by_clause&gt;
                      | &lt;limit_clause&gt;
                      | &lt;group_by_clause&gt;
                      | &lt;browse_by_clause&gt;
                      | &lt;fetching_stored_clause&gt;

&lt;order_by_clause&gt; ::= ORDER BY &lt;sort_specs&gt;

&lt;sort_specs&gt; ::= &lt;sort_spec&gt; ( ',', &lt;sort_spec&gt; )*

&lt;sort_spec&gt; ::= &lt;column_name&gt; [&lt;ordering_spec&gt;]

&lt;ordering_spec&gt; ::= ASC | DESC

&lt;group_by_clause&gt; ::= GROUP BY &lt;group_spec&gt;

&lt;group_spec&gt; ::= &lt;facet_name&gt; [TOP &lt;max_per_group&gt;]

&lt;limit_clause&gt; ::= LIMIT [&lt;offset&gt; ','] &lt;count&gt;

&lt;offset&gt; ::= ( &lt;digit&gt; )+

&lt;count&gt; ::= ( &lt;digit&gt; )+

&lt;browse_by_clause&gt; ::= BROWSE BY &lt;facet_specs&gt;

&lt;facet_specs&gt; ::= &lt;facet_spec&gt; ( ',' &lt;facet_spec&gt; )*

&lt;facet_spec&gt; ::= &lt;facet_name&gt; [&lt;facet_expression&gt;]

&lt;facet_expression&gt; ::= '(' &lt;expand_flag&gt; &lt;count&gt; &lt;count&gt; &lt;facet_ordering&gt; ')'

&lt;expand_flag&gt; ::= TRUE | FALSE

&lt;facet_ordering&gt; ::= HITS | VALUE

&lt;fetching_stored_clause&gt; ::= FETCHING STORED [&lt;fetching_flag&gt;]

&lt;fetching_flag&gt; ::= TRUE | FALSE

&lt;quoted_string&gt; ::= '"' ( &lt;char&gt; )* '"'
                  | "'" ( &lt;char&gt; )* "'"

&lt;identifier&gt; ::= &lt;identifier_start&gt; ( &lt;identifier_part&gt; )*

&lt;identifier_start&gt; ::= &lt;alpha&gt; | '-' | '_'

&lt;identifier_part&gt; ::= &lt;identifier_start&gt; | &lt;digit&gt;

&lt;column_name&gt; ::= &lt;identifier&gt;

&lt;facet_name&gt; ::= &lt;identifier&gt;

&lt;alpha&gt; ::= &lt;alpha_lower_case&gt; | &lt;alpha_upper_case&gt;

&lt;alpha_upper_case&gt; ::= A | B | C | D | E | F | G | H | I | J | K | L | M | N | O
                     | P | Q | R | S | T | U | V | W | X | Y | Z

&lt;alpha_lower_case&gt; ::= a | b | c | d | e | f | g | h | i | j | k | l | m | n | o
                     | p | q | r | s | t | u | v | w | x | y | z

&lt;digit&gt; ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

&lt;numeric&gt; ::= &lt;time_expr&gt; | &lt;number&gt;

&lt;number&gt; ::= &lt;integer&gt; | &lt;real&gt;

&lt;integer&gt; ::= ( &lt;digit&gt; )+

&lt;real&gt; ::= ( &lt;digit&gt; )+ '.' ( &lt;digit&gt; )+

&lt;time_expr&gt; ::= &lt;time_span&gt; AGO
              | &lt;date_time_string&gt;
              | NOW

&lt;time_span&gt; ::= [&lt;time_week_part&gt;] [&lt;time_day_part&gt;] [&lt;time_hour_part&gt;]
                [&lt;time_minute_part&gt;] [&lt;time_second_part&gt;] [&lt;time_millisecond_part&gt;]

&lt;time_week_part&gt; ::= &lt;integer&gt; ( 'week' | 'weeks' )

&lt;time_day_part&gt;  ::= &lt;integer&gt; ( 'day'  | 'days' )

&lt;time_hour_part&gt; ::= &lt;integer&gt; ( 'hour' | 'hours' )

&lt;time_minute_part&gt; ::= &lt;integer&gt; ( 'minute' | 'minutes' | 'min' | 'mins')

&lt;time_second_part&gt; ::= &lt;integer&gt; ( 'second' | 'seconds' | 'sec' | 'secs')

&lt;time_millisecond_part&gt; ::= &lt;integer&gt; ( 'millisecond' | 'milliseconds' | 'msec' | 'msecs')

&lt;date_time_string&gt; ::= &lt;digit&gt;&lt;digit&gt;&lt;digit&gt;&lt;digit&gt; ('-' | '/' ) &lt;digit&gt;&lt;digit&gt;
                       ('-' | '/' ) &lt;digit&gt;&lt;digit&gt;
                       &lt;digit&gt;&lt;digit&gt; ':' &lt;digit&gt;&lt;digit&gt; ':' &lt;digit&gt;&lt;digit&gt;

</pre>

<h2>BQL Statement Syntax</h2>

<h3>DESCRIBE Statement</h3>

<p>DESCRIBE statement provides the information about the index
(or <span class="emphasis"><em>table</em></span> in RDBM terminology).
In Sensei, the index name is optional because when a Sensei client sends
a query to a Sensei REST endpoint, only one index is accessible.  The
index name in a DESCRIBE statement is simply ignored.</p>

<p>The keyword "DESCRIBE" can also be written as "DESC".</p>

<p><strong>Example Statement:</strong></p>

<pre>
DESC cars;
</pre>

<p><span class="bold"><strong>Results:</strong></span></p>

<pre>
+------------+------------+---------+-----------+-------------+---------+
| facet_name | facet_type | runtime | column    | column_type | depends |
+------------+------------+---------+-----------+-------------+---------+
| category   | simple     | false   | category  | string      | []      |
| groupid    | simple     | false   | groupid   | long        | []      |
| city       | path       | false   | city      | string      | []      |
| color      | simple     | false   | color     | string      | []      |
| tags       | multi      | false   | tags      | string      | []      |
| price      | range      | false   | price     | float       | []      |
| makemodel  | path       | false   | makemodel | string      | []      |
| mileage    | range      | false   | mileage   | int         | []      |
| year       | range      | false   | year      | int         | []      |
+------------+------------+---------+-----------+-------------+---------+
</pre>

<h3>SELECT Statement</h3>

<p>SELECT is the only Data Manipulation Language (DML) that Sensei
supports today.  It is used to retrieve a set of documents based on
conditions specified in the WHERE clause.</p>

<p>The SELECT statement takes the following form:</p>

<pre>
SELECT &lt;select_list&gt;
[ FROM &lt;index&gt; ]
[ WHERE &lt;search_expr&gt; ]
[ GIVEN FACET PARAM &lt;facet_param_list&gt; ]
( &lt;order_by_clause&gt;
  | &lt;group_by_clause&gt;
  | &lt;limit_clause&gt;
  | &lt;browse_by_clause&gt;
  | &lt;fetching_stored_clause&gt;
)*
</pre>

<p>Most of the syntax is similar to SQL.  So if you are familiar with
SQL, you should be ready to write some basic BQL queries right away.  In
addition to the basic SQL syntax, BQL includes several new features to
support faceted search and syntactic sugar to make real-time search
queries easier.</p>

<p>We'll describe different pieces of the SELECT statement in more
details in the following sections.</p>

<h4>Select List</h4>

<p>The select list in a SELECT statement can simply be a
"<code>*</code>" or a
comma-separated <span class="emphasis"><em>column</em></span> names.  If
"<code>*</code>" is given, it means all columns in the index are
selected.</p>

<p>A column in the select list is either a facet name or a field name in
the index.  Column names are case-sensitive in BQL because they have to
match what are defined in the index schema.  If a column is unknown to
Sensei server, then it is discarded on the server side.</p>

<p>Sensei reserves several internal column names, which are all named
with a leading "<code>_</code>", e.g. "<code>_uid</code>".  Try to avoid
naming any column with a leading "<code>_</code>".</p>

<h4>FROM Clause</h4>

<p>Just like the index name in a DESCRIBE statement is optional, the
FROM clause in a SELECT statement is also optional.</p>

<h4>WHERE Clause</h4>

<p>The WHERE clause, if given, specifies the search conditions that all
documents must satisfy to be selected.  Conditions are expressed as a
Boolean expression consisting of one or more predicates.  The following
predicates are supported in BQL.</p>

<ul>
  <li><p>IN predicate</p></li>
  <li><p>CONTAINS ALL predicate</p></li>
  <li><p>Equal predicate</p></li>
  <li><p>Not equal predicate</p></li>
  <li><p>Query predicate</p></li>
  <li><p>Range predicate</p></li>
  <li><p>BETWEEN predicate</p></li>
  <li><p>Time predicate</p></li>
  <li><p>MATCH AGAINST predicate</p></li>
  <li><p>LIKE predicate</p></li>
</ul>


<h4>Predicate</h4>

<h5>IN Predicate</h5>

<p>This predicate specifies that the value(s) of a column has to have,
or not have, in the selected documents.  For example:</p>

<ul>
  <li>
    <p><code>color IN ("red", "blue")</code></p>

    <p>Each document in the search results much have color "red" or
    "blue".</p>
  </li>

  <li>
    <p><code>tags IN ("cool", "leather") EXCEPT ("moon-roof",
    "automatic") </code></p>

    <p>Each document in the search results should have a tag of "cool"
    or "leather", but cannot have a tag of "moon-roof" or
    "automatic". </p>
  </li>

  <li>
    <p><code>age IN (10, 20, 30)</code></p>

    <p>Each document in the search results must have a age of 10, 20, or
    30.</p>
  </li>
</ul>

<h5>CONTAINS ALL Predicate</h5>

<p>This predicate specifies that a multi-value column has to
contain <span class="emphasis"><em>all</em></span> the given values in
the selected documents.  For example:</p>

<ul>
  <li>
    <p><code>tags CONTAINS ALL ("cool", "hybrid") EXCEPT("favorite")</code></p>

    <p>Each document in the search results must have two tags: "cool"
    and "hybrid".  However, it cannot have the tag of "favorite".</p>
  </li>
</ul>

<h5>Equal Predicate</h5>

<p>This predicate specifies that a column has to have the given value in
the selected documents.  For example:</p>

<ul>
  <li>
    <p><code>color = "red"</code></p>

    <p>Each document in the search results must have a color of
    "red".</p>
  </li>
</ul>

<h5>Not Equal Predicate</h5>

<p>This predicate specifies the value that a column cannot have in the
selected documents.  For example:</p>

<ul>
  <li>
    <p><code>color &lt;&gt; "red"</code></p>
  </li>
</ul>

<h5>Query Predicate</h5>

<p>This predicate is used to do full text search on the
internal <span class="emphasis"><em>contents</em></span> column.  All
Lucene query syntax is supported.  For example:</p>

<ul>
  <li>
    <p><code>QUERY IS "hybrid AND (cool or moon-roof)"</code></p>
  </li>
</ul>

<h5>Range Predicate</h5>

<p>This predicate is used to specify a value range for a range facet.
For example:</p>

<ul>
  <li><p><code>year &gt; 1999</code></p></li>
  <li><p><code>year &lt;= 2002</code></p></li>
  <li><p><code>price &lt; 17500</code></p></li>
  <li><p><code>time &gt;= 2011-10-20 15:30:00</code></p></li>
  <li><p><code>time &lt; 2011/12/31 10:00:00</code></p></li>
</ul>

<h5>BETWEEN Predicate</h5>

<p>This predicate specifies that a range facet column has to be within a
bound for all selected documents.  Both upper bound and lower bound are
inclusive.  For example:</p>

<ul>
  <li>
    <p><code>year BETWEEN 1995 AND 2000</code></p>
  </li>
</ul>

<h5>Time Predicate</h5>

<p>This predicate is used on a column that contains time stamp values
(and the column should be a range facet too).  This is useful to search
documents that are indexed in real-time.  For example:</p>

<ul>
  <li><p><code>time IN LAST 2 hours 10 mins 30 secs 100 msecs</code></p></li>
  <li><p><code>time SINCE 2 weeks AGO</code></p></li>
  <li><p><code>time NOT BEFORE 2 weeks AGO</code></p></li>
  <li><p><code>time AFTER 2011-10-20 15:30:00</code></p></li>
</ul>

<h5>MATCH AGAINST Predicate</h5>

<p>This predicate is used to perform full text searches on one or more
columns that have a string data type.  When more than one columns are
given in the predicate, then any column in the list that contains
specified searched string would make a document satisfy this condition.
For example:
</p>

<ul>
  <li>
    <p><code>MATCH(color) AGAINST("bl*")</code></p>

    <p>All cars that have a "black" or "blue" color would satisfy this
    predicate.</p>
  </li>

  <li>
    <p><code>MATCH(category) AGAINST("*van")</code></p>

    <p>All cars in the category of "van" or "mini-van" would satisfy
    this predicate.</p>
  </li>
  
  <li>
    <p><code>MATCH(color, category) AGAINST("*ac*")</code></p>

    <p>A car with a "black" or "blue" color, or with a category of
    "compact" would satisfy this condition.</p>
  </li>
</ul>

<h5>LIKE Predicate</h5>

<p>This is a predicate to do wildcard text match.  Two wildcards are
supported: <code>%</code> and <code>_</code>.  Wildcard <code>%</code>
matches zero or more characters, while <code>_</code> matches exactly
one character.  For example:</p>

<ul>
  <li>
    <p><code>color LIKE "bl%"</code></p>

    <p>All cars that have a "black" or "blue" color would satisfy this
    predicate.</p>
  </li>

  <li>
    <p><code>color LIKE "bl__"</code></p>

    <p>All cars with a "blue" color would satisfy this condition, but
    the cars with a "black" color would not.</p>
  </li>
</ul>

<p>Note that wildcards <code>%</code> and <code>_</code>, not
Lucene's <code>*</code> and <code>?</code> are used in BQL.  This is
mainly to make BQL more compatible with SQL.  However, if <code>*</code>
or <code>?</code> is used, it is also accepted.</p>


<h4>ORDER BY Clause</h4>

<p>ORDER BY clause specifies how you want to have the search results
sorted.  You can sort the results based on one or multiple columns, in
either ascending or descending order.</p>

<p>The clause takes the following form:</p>

<pre>
ORDER BY &lt;column_name&gt; [(ASC | DESC)] (',' &lt;column_name&gt; [(ASC | DESC)])*
</pre>

<p>ORDER BY clause can only be specified once in a SELECT statement.</p>

<h4>LIMIT Clause</h4>

<p>LIMIT clause specifies how many results you want to get and what the
starting offset is in the entire matched document set.</p>

<p>A LIMIT clause takes one of the following two formats:</p>

<pre>
LIMIT &lt;count&gt;
</pre>

<pre>
LIMIT &lt;offset&gt; ',' &lt;count&gt;
</pre>

<p>By default, the offset is set to 0 and the count is set to 10.</p>

<p>LIMIT clause can only be specified once in a SELECT statement.</p>


<h4>GROUP BY Clause</h4>

<p>GROUP BY clause supports the grouping of search results based on a
facet.  It takes the following form:</p>

<pre>
GROUP BY &lt;facet_name&gt; [TOP &lt;max_per_group&gt;]
</pre>

<p>The facet name in a GROUP BY clause has to be a defined facet in the
index.  A non-facet column cannot be used to do group-by. <code>[TOP
&lt;max_per_group&gt;]</code> specifies how many results you want to
have for each group.  If it is omitted, the default value is 10.</p>

<p>GROUP BY clause can only be specified once in a SELECT statement.</p>


<h4>BROWSE BY Clause</h4>

<p>This clause is a BQL feature for faceted search.  You can use it to
get the facet count information for one or multiple facets returned with
the search results.  A BROWSE BY clause takes the following form:</p>

<pre>BROWSE BY &lt;facet_spec&gt; ( ',' &lt;facet_spec&gt; )*</pre>

<p>where each <code>&lt;facet_spec&gt;</code> is defined as:</p>

<pre>
&lt;facet_name&gt; ['(' &lt;expand_flag&gt; &lt;count&gt;&lt;count&gt; &lt;facet_ordering&gt; ')']
</pre>

<p>Here, each <code>&lt;facet_spec&gt;</code> optionally specifies the
following information about the facet you want to get the facet count
information for:</p>

<ol>
  <li>
    <p>whether the selection is expanded (default false)</p>
  </li>

  <li>
    <p>the minimum number of hit counts (the
    first <code>&lt;count&gt;</code>)</p>
  </li>

  <li>
    <p>the maximum number of hit counts (the
    second <code>&lt;count&gt;</code>)</p>
  </li>

  <li>
    <p>facet ordering method: "<code>hits</code>" or
    "<code>value</code>" (default "<code>hits</code>")</p>
  </li>
</ol>

<p>BROWSE BY clause can only be specified once in a SELECT
statement.</p>


<h4>GIVEN FACET PARAM Clause</h4>

<p>In a faceted search system, a run-time facet handler usually requires
initialization parameter(s) to be provided at search time for each
query.  For example, in a search system that searches LinkedIn shares or
Twitter tweets, one or more run-time facets usually require the searcher
to provide his/her user Id (or user name) and the time when the search
is performed.</p>

<p>One run-time facet may need multiple initialization parameters, each
of which has a different name and/or a different data type.  These
parameters can be specified in the SELECT statement using the GIVEN
FACET PARAM clause, which takes the following form:</p>

<pre>
GIVEN FACET PARAM &lt;facet_param&gt; ( ',' &lt;facet_param&gt; )*
</pre>

<p>Each <code>&lt;facet_param&gt;</code> is specified as a 4-typle:</p>

<pre>
'(' &lt;facet_name&gt; &lt;facet_param_name&gt; &lt;facet_param_type&gt; &lt;facet_param_value&gt; ')'
</pre>

<p>All the information in this tuple should match what is defined in the
schema for this facet.</p>

<p>GIVEN FACET PARAM clause can only be specified once in a SELECT
statement.</p>


<h4>FETCHING STORED Clause</h4>

<p>This clause specifies if you want to retrieve the source data of the
documents in the search results.  It take the following format:</p>

<pre>FETCHING STORED (TRUE | FALSE)?</pre>

<p>When the TRUE or FALSE value is not specified, the value is set to
TRUE.  If this clause itself is not specified in the SELECT statement,
the flag is implicitly set to FALSE.</p>

<p>FETCHING STORED clause can only be specified once in a SELECT
statement.</p>


<h3>Comments in BQL Statements</h3>

<p>You can include comments in your BQL statements.  Comments may be
needed for some complicated queries.</p>

<p>Two comment styles are supported:</p>

<ol class="orderedlist" type="1">
  <li>
    <p>Block comments</p>

    <p>Block comments in BQL are similar to the block comments in C.  A
    block comment can span multiple lines.  All characters inside a pair
    of <code>/*</code> and <code>*/</code> are treated as part of a
    block comment and ignored by BQL parser.</p>

    <p><span class="emphasis"><em>Example:</em></span></p>

    <pre>
SELECT *
FROM   cars
WHERE  /* Here is my comment, we are going to
          add some search conditions here.
        */
       color = 'red'
AND    year &gt; 1999
    </pre>
  </li>

  <li>
    <p>Line comments</p>

    <p>A line comment in BQL starts with <code>--</code>.  All
    characters after <code>--</code> on the same line will be treated as
    comments and ignored by BQL parser.</p>

    <p><span class="emphasis"><em>Example:</em></span></p>

    <pre>
SELECT *
FROM   cars    -- Comment: the index name "cars" is optional
WHERE  color = 'red'
    </pre>
  </li>
</ol>


<h2>Query Examples</h2>

<p>The best way to learn about BQL is to learn from BQL query examples.
In this section, we are going to present a series of BQL queries that
cover most of the main features.</p>

<h3>The Simplest Query</h3>

<p><span class="bold"><strong>Find the first 10 cars in the index:</strong></span></p>

<pre>
SELECT * FROM cars;
</pre>

<p>This query searches for the top 10 cars, sorted by time, from index
cars.  All columns are selected.  Number 10 is the default number of
results to be returned, and time is the default order-by column.</p>

<p><span class="bold"><strong>Results:</strong></span></p>

<pre>
+---------------+---------------------------------+ ... +-------+
| category      | city                            |     | uid   |
+---------------+---------------------------------+ ... +-------+
| station wagon | u.s.a./florida/tampa            |     | 14999 |
| compact       | u.s.a./florida/tampa            |     | 0     |
| exotic        | u.s.a./florida/tampa            |     | 242   |
| compact       | u.s.a./texas/houston            |     | 1     |
| compact       | u.s.a./california/sunnyvale     |     | 241   |
| compact       | u.s.a./texas/houston            |     | 2     |
| exotic        | u.s.a./california/san francisco |     | 244   |
| compact       | u.s.a./california/san francisco |     | 243   |
| compact       | u.s.a./california/sacramento    |     | 3     |
| compact       | u.s.a./california/san diego     |     | 4     |
+---------------+---------------------------------+ ... +-------+
10 rows in set, 15000 hits, 15000 total docs (server: 20ms, total: 68ms)</pre>

<h3>Queries with Limited Number of Results</h3>

<p>You can use the limit clause in a query to specify the starting
offset and number of documents to be returned in the results. By
default, the starting offset is 0, and number of results to be returned
is 10. If only one number is specified in the limit clause, then it is
treated the number of results.</p>

<p>The limit clause is mainly used for pagination on search result
age.</p>

<ol>
  <li>
    <p><span class="bold"><strong>Find the next 10 cars starting from
    offset 5:</strong></span></p>

    <pre>
SELECT *
FROM   cars
LIMIT  5, 10
    </pre>

    <p><span class="bold"><strong>Results:</strong></span></p>

    <pre>
+----------+---------------------------------+ ... +-----+
| category | city                            |     | uid |
+----------+---------------------------------+ ... +-----+
| compact  | u.s.a./texas/houston            |     | 2   |
| exotic   | u.s.a./california/san francisco |     | 244 |
| compact  | u.s.a./california/sacramento    |     | 3   |
| exotic   | china/beijing                   |     | 245 |
| compact  | u.s.a./california/san diego     |     | 4   |
| exotic   | u.s.a./new york/rochester       |     | 246 |
| compact  | china/shanghai                  |     | 5   |
| exotic   | u.s.a./new york/binghamton      |     | 247 |
| compact  | u.s.a./utah/salt lake city      |     | 6   |
| exotic   | china/shanghai                  |     | 248 |
+----------+---------------------------------+ ... +-----+
10 rows in set, 15000 hits, 15000 total docs (server: 10ms, total: 60ms)
    </pre>
  </li>

  <li>
    <p><span class="bold"><strong>Just get the top 3
    results:</strong></span></p>

    <pre>
SELECT *
FROM   cars
LIMIT  3
    </pre>

    <p><span class="bold"><strong>Results:</strong></span></p>

    <pre>
+----------+-----------------------------+ ... +-----+
| category | city                        |     | uid |
+----------+-----------------------------+ ... +-----+
| compact  | u.s.a./california/sunnyvale |     | 1   |
| compact  | u.s.a./florida/tampa        |     | 0   |
| exotic   | u.s.a./florida/tampa        |     | 242 |
+----------+-----------------------------+ ... +-----+
3 rows in set, 15001 hits, 15001 total docs (server: 7ms, total: 27ms)
    </pre>
  </li>
</ol>


<h3>Queries with Basic Conditions</h3>

<ol>
  <li>
    <p><span class="bold"><strong>Find all red cars:</strong></span></p>

    <pre>
SELECT color, year, makemodel
FROM   cars
WHERE  color = "red"
    </pre>

    <p><span class="bold"><strong>Results:</strong></span></p>

    <pre>
+-------+----------------------+------------------------+
| color | year                 | makemodel              |
+-------+----------------------+------------------------+
| red   | 00000000000000001996 | european/bentley/azure |
| red   | 00000000000000001995 | european/bentley/azure |
| red   | 00000000000000002000 | european/bentley/azure |
| red   | 00000000000000001995 | european/bentley/azure |
| red   | 00000000000000001994 | european/bentley/azure |
| red   | 00000000000000001995 | asian/acura/3.2tl      |
| red   | 00000000000000001996 | asian/acura/3.2tl      |
| red   | 00000000000000001999 | european/bentley/azure |
| red   | 00000000000000002002 | european/bentley/azure |
| red   | 00000000000000001996 | asian/acura/integra    |
+-------+----------------------+------------------------+
10 rows in set, 2160 hits, 15000 total docs (server: 5ms, total: 41ms)
    </pre>

  </li>

  <li>
    <p><span class="bold"><strong>Find all red and blue cars:</strong></span></p>

    <pre>
SELECT color, year, makemodel
FROM   cars
WHERE  color IN ("red", "blue")
    </pre>

    <p><span class="bold"><strong>Results:</strong></span></p>

    <pre>
+-------+----------------------+------------------------+
| color | year                 | makemodel              |
+-------+----------------------+------------------------+
| blue  | 00000000000000001999 | asian/acura/tl         |
| red   | 00000000000000001996 | european/bentley/azure |
| blue  | 00000000000000001998 | asian/acura/tl         |
| red   | 00000000000000001995 | european/bentley/azure |
| blue  | 00000000000000001995 | asian/acura/1.6el      |
| red   | 00000000000000002000 | european/bentley/azure |
| blue  | 00000000000000001993 | asian/acura/3.2tl      |
| blue  | 00000000000000001998 | asian/acura/tl         |
| red   | 00000000000000001995 | european/bentley/azure |
| red   | 00000000000000001994 | european/bentley/azure |
+-------+----------------------+------------------------+
10 rows in set, 3264 hits, 15000 total docs (server: 4ms, total: 33ms)
    </pre>

  </li>

  <li>
    <p><span class="bold"><strong>Find all 1999 or 2000 cars that are not black nor red:</strong></span></p>

    <pre>
SELECT color, year, makemodel
FROM   cars
WHERE  color NOT IN ("black", "red")
AND    year BETWEEN 1999 AND 2000
    </pre>

    <p><span class="bold"><strong>Results:</strong></span></p>

    <pre>
+--------+----------------------+------------------------+
| color  | year                 | makemodel              |
+--------+----------------------+------------------------+
| blue   | 00000000000000001999 | asian/acura/tl         |
| white  | 00000000000000001999 | asian/acura/1.6el      |
| yellow | 00000000000000001999 | asian/acura/3.2tl      |
| silver | 00000000000000002000 | asian/acura/3.5rl      |
| silver | 00000000000000002000 | asian/acura/3.5rl      |
| yellow | 00000000000000002000 | asian/acura/integra    |
| yellow | 00000000000000002000 | asian/acura/integra    |
| yellow | 00000000000000002000 | european/bentley/azure |
| yellow | 00000000000000002000 | european/bentley/azure |
| yellow | 00000000000000002000 | asian/acura/tl         |
+--------+----------------------+------------------------+
10 rows in set, 1934 hits, 15000 total docs (server: 4ms, total: 35ms)
    </pre>
  </li>

  <li>
    <p><span class="bold"><strong>Find all cars in New York state:</strong></span></p>

    <pre>
SELECT color, city, price
FROM   cars
WHERE  city in ("u.s.a./new york")
    </pre>

    <p><span class="bold"><strong>Results:</strong></span></p>

    <pre>
+--------+----------------------------+-------------------------+
| color  | city                       | price                   |
+--------+----------------------------+-------------------------+
| white  | u.s.a./new york/albany     | 00000000000000007500.00 |
| red    | u.s.a./new york/rochester  | 00000000000000014500.00 |
| green  | u.s.a./new york/syracuse   | 00000000000000009500.00 |
| yellow | u.s.a./new york/binghamton | 00000000000000007200.00 |
| blue   | u.s.a./new york/new york   | 00000000000000009300.00 |
| yellow | u.s.a./new york/new york   | 00000000000000015400.00 |
| yellow | u.s.a./new york/new york   | 00000000000000015200.00 |
| black  | u.s.a./new york/albany     | 00000000000000009200.00 |
| gold   | u.s.a./new york/new york   | 00000000000000011100.00 |
| red    | u.s.a./new york/rochester  | 00000000000000009500.00 |
+--------+----------------------------+-------------------------+
10 rows in set, 2781 hits, 15000 total docs (server: 5ms, total: 37ms)
    </pre>
  </li>
</ol>


<h3>Queries with AND, OR, and NOT Logic in Value Selections</h3>

<ol class="orderedlist" type="1">
  <li>
    <p><span class="bold"><strong>Find all cars tagged with
    both <code>"cool"</code> and <code>"hybrid"</code> but
    not <code>"favorite"</code>:</strong></span></p>

    <pre>
SELECT tags, price from cars
WHERE  tags CONTAINS ALL ("cool", "hybrid") EXCEPT("favorite")
LIMIT  5
    </pre>

    <p><span class="bold"><strong>Results:</strong></span></p>

    <pre>
+----------------------------------+-------------------------+
| tags                             | price                   |
+----------------------------------+-------------------------+
| automatic,cool,hybrid,reliable   | 00000000000000009400.00 |
| cool,hybrid,moon-roof,navigation | 00000000000000011500.00 |
| automatic,cool,hybrid,reliable   | 00000000000000006300.00 |
| cool,hybrid,moon-roof,reliable   | 00000000000000006500.00 |
| cool,hybrid,moon-roof,reliable   | 00000000000000007100.00 |
+----------------------------------+-------------------------+
5 rows in set, 491 hits, 15000 total docs (server: 9ms, total: 28ms)
    </pre>
  </li>

  <li>
    <p><span class="bold"><strong>Find all cars tagged with
    either <code>"cool"</code> or <code>"hybrid"</code> but
    not <code>"mp3"</code></strong></span>:</p>

    <pre>
SELECT tags, price
FROM   cars
WHERE  tags IN ("cool", "hybrid") EXCEPT ("mp3")
LIMIT  5
    </pre>

    <p><span class="bold"><strong>Results:</strong></span></p>

    <pre>
+----------------------------------------------+-------------------------+
| tags                                         | price                   |
+----------------------------------------------+-------------------------+
| hybrid,leather,moon-roof,reliable            | 00000000000000007500.00 |
| automatic,chick magnet,cool,highend,reliable | 00000000000000014200.00 |
| cool,electric,favorite,navigation            | 00000000000000007300.00 |
| cool,electric,favorite,reliable              | 00000000000000007200.00 |
| automatic,hybrid,leather,reliable            | 00000000000000007100.00 |
+----------------------------------------------+-------------------------+
5 rows in set, 8176 hits, 15000 total docs (server: 6ms, total: 25ms)
    </pre>

  </li>
</ol>


<h3>Having Search Results Sorted</h3>

<p>You can sort the search result based on one or more columns, in
either ascending (the default) or descending order.</p>

<ol class="orderedlist" type="1">
  <li>
    <p><span class="bold"><strong>Find the top 5 cheapest but newest
    cars.</strong></span></p>

    <pre>
SELECT   year, makemodel, price
FROM     cars
ORDER BY year desc, price
LIMIT    5
    </pre>

    <p><span class="bold"><strong>Results:</strong></span></p>

    <pre>
+----------------------+-------------------------------+-------------------------+
| year                 | makemodel                     | price                   |
+----------------------+-------------------------------+-------------------------+
| 00000000000000002002 | asian/subaru/justy            | 00000000000000002100.00 |
| 00000000000000002002 | asian/subaru/justy            | 00000000000000002100.00 |
| 00000000000000002002 | north american/dodge/colt     | 00000000000000002400.00 |
| 00000000000000002002 | north american/mercury/tracer | 00000000000000002400.00 |
| 00000000000000002002 | north american/mercury/tracer | 00000000000000002500.00 |
+----------------------+-------------------------------+-------------------------+
5 rows in set, 15000 hits, 15000 total docs (server: 22ms, total: 50ms)
    </pre>
  </li>

  <li>
    <p><span class="bold"><strong>Find the top 5 most expensive but
    oldest cars:</strong></span></p>

    <pre>
SELECT   year, makemodel, price
FROM     cars
ORDER BY year asc, price desc
LIMIT    5
    </pre>

    <p><span class="bold"><strong>Results:</strong></span></p>

    <pre>
+----------------------+-----------------------------+-------------------------+
| year                 | makemodel                   | price                   |
+----------------------+-----------------------------+-------------------------+
| 00000000000000001993 | european/ferrari/360 modena | 00000000000000019500.00 |
| 00000000000000001993 | asian/acura/nsx             | 00000000000000019500.00 |
| 00000000000000001993 | european/aston martin/db7   | 00000000000000019500.00 |
| 00000000000000001993 | european/ferrari/360 modena | 00000000000000019500.00 |
| 00000000000000001993 | asian/acura/nsx             | 00000000000000019500.00 |
+----------------------+-----------------------------+-------------------------+
5 rows in set, 15000 hits, 15000 total docs (server: 5ms, total: 27ms)
    </pre>

  </li>
</ol>

<h3>Queries Using MATCH AGAINST Predicate</h3>

<ol>
  <li>
    <p>Find all the cars with color "black" or "blue":</p>

    <pre>
SELECT color, year, makemodel
FROM   cars
WHERE  MATCH(color) AGAINST("bl*")
    </pre>

    <p><span class="emphasis"><em>Results:</em></span></p>

    <pre>
+-------+----------------------+---------------------+
| color | year                 | makemodel           |
+-------+----------------------+---------------------+
| blue  | 00000000000000001993 | asian/acura/3.2tl   |
| black | 00000000000000001994 | asian/acura/3.2tl   |
| black | 00000000000000001999 | asian/acura/3.5rl   |
| black | 00000000000000002002 | asian/acura/3.5rl   |
| black | 00000000000000002000 | asian/acura/3.5rl   |
| black | 00000000000000001996 | asian/acura/integra |
| black | 00000000000000001996 | asian/acura/integra |
| black | 00000000000000001993 | asian/acura/integra |
| black | 00000000000000001999 | asian/acura/integra |
| black | 00000000000000001994 | asian/acura/integra |
+-------+----------------------+---------------------+
10 rows in set, 4245 hits, 15000 total docs (server: 8ms, total: 46ms)
    </pre>
  </li>

  <li>
    <p>Find all the cars with color column or category column containing
    substring "<code>ac</code>" (like color "black" or category
    "compact"):</p>

    <pre>
SELECT color, category, year, makemodel
FROM   cars
WHERE  MATCH(color, category) AGAINST("*ac*")
LIMIT  20
    </pre>

    <p><span class="emphasis"><em>Results:</em></span></p>

    <pre>
+--------+------------+----------------------+---------------------+
| color  | category   | year                 | makemodel           |
+--------+------------+----------------------+---------------------+
| white  | compact    | 00000000000000001993 | asian/acura/1.6el   |
| white  | compact    | 00000000000000001999 | asian/acura/1.6el   |
| gold   | compact    | 00000000000000001996 | asian/acura/1.6el   |
| silver | compact    | 00000000000000001997 | asian/acura/1.6el   |
| blue   | compact    | 00000000000000001993 | asian/acura/3.2tl   |
| gold   | compact    | 00000000000000002001 | asian/acura/3.2tl   |
| black  | compact    | 00000000000000001994 | asian/acura/3.2tl   |
| green  | compact    | 00000000000000001995 | asian/acura/3.2tl   |
| yellow | compact    | 00000000000000001999 | asian/acura/3.2tl   |
| gold   | compact    | 00000000000000001993 | asian/acura/3.2tl   |
| red    | compact    | 00000000000000001996 | asian/acura/3.2tl   |
| black  | luxury     | 00000000000000001999 | asian/acura/3.5rl   |
| black  | luxury     | 00000000000000002002 | asian/acura/3.5rl   |
| black  | luxury     | 00000000000000002000 | asian/acura/3.5rl   |
| black  | sports car | 00000000000000001996 | asian/acura/integra |
| black  | sports car | 00000000000000001996 | asian/acura/integra |
| black  | sports car | 00000000000000001993 | asian/acura/integra |
| black  | sports car | 00000000000000001999 | asian/acura/integra |
| black  | sports car | 00000000000000001994 | asian/acura/integra |
| black  | sports car | 00000000000000001993 | asian/acura/integra |
+--------+------------+----------------------+---------------------+
20 rows in set, 7178 hits, 15000 total docs (server: 4ms, total: 134ms)
    </pre>
  </li>

  <li>
    <p>Find all the car categories that are not van nor mini-van:</p>

    <pre>
SELECT   color, category, year, makemodel
FROM     cars
WHERE    NOT MATCH(color, category) AGAINST("*van")
GROUP BY category TOP 1
LIMIT    1000
    </pre>

    <p><span class="emphasis"><em>Results:</em></span></p>

    <pre>
+--------+---------------+----------------------+-----------------------------+
| color  | category      | year                 | makemodel                   |
+--------+---------------+----------------------+-----------------------------+
| white  | compact       | 00000000000000001993 | asian/acura/1.6el           |
| white  | luxury        | 00000000000000001995 | asian/acura/3.5rl           |
| red    | sports car    | 00000000000000001996 | asian/acura/integra         |
| yellow | exotic        | 00000000000000001997 | european/aston martin/db7   |
| black  | sedan         | 00000000000000001997 | north american/eagle/vision |
| green  | suv           | 00000000000000002002 | north american/ford/bronco  |
| yellow | truck         | 00000000000000002001 | asian/isuzu/pickup          |
| green  | station wagon | 00000000000000001995 | north american/saturn/sw    |
| gold   | sub-compact   | 00000000000000001993 | north american/ford/aspire  |
+--------+---------------+----------------------+-----------------------------+
9 rows in set, 6980 hits, 7500 total docs (server: 5ms, total: 84ms)
    </pre>

    <p>You can compare the above results (containing 9 rows) with the
    ones from the following query (containing 11 rows):</p>

    <pre>
SELECT   color, category, year, makemodel
FROM     cars
GROUP BY category TOP 1
LIMIT    1000
    </pre>

    <p><span class="emphasis"><em>Results:</em></span></p>

    <pre>
+--------+---------------+----------------------+------------------------------------+
| color  | category      | year                 | makemodel                          |
+--------+---------------+----------------------+------------------------------------+
| white  | compact       | 00000000000000001993 | asian/acura/1.6el                  |
| white  | luxury        | 00000000000000001995 | asian/acura/3.5rl                  |
| red    | sports car    | 00000000000000001996 | asian/acura/integra                |
| yellow | exotic        | 00000000000000001997 | european/aston martin/db7          |
| black  | sedan         | 00000000000000001997 | north american/eagle/vision        |
| green  | suv           | 00000000000000002002 | north american/ford/bronco         |
| green  | van           | 00000000000000001994 | north american/ford/club wagon     |
| yellow | truck         | 00000000000000002001 | asian/isuzu/pickup                 |
| green  | station wagon | 00000000000000001995 | north american/saturn/sw           |
| white  | mini-van      | 00000000000000001993 | north american/chevrolet/astro van |
| gold   | sub-compact   | 00000000000000001993 | north american/ford/aspire         |
+--------+---------------+----------------------+------------------------------------+
11 rows in set, 15000 hits, 15000 total docs (server: 7ms, total: 50ms)
    </pre>

  </li>
</ol>


<h3>Queries Using LIKE Predicate</h3>

<ol>
  <li>
    <p>Find all the cars with color "black" or "blue":</p>

    <pre>
SELECT color, year, makemodel
FROM   cars
WHERE  color LIKE "bl%"
    </pre>

    <p><span class="emphasis"><em>Results:</em></span></p>

    <pre>
+-------+------------+----------------------+---------------------+
| color | category   | year                 | makemodel           |
+-------+------------+----------------------+---------------------+
| blue  | compact    | 00000000000000001993 | asian/acura/3.2tl   |
| black | compact    | 00000000000000001994 | asian/acura/3.2tl   |
| black | luxury     | 00000000000000001999 | asian/acura/3.5rl   |
| black | luxury     | 00000000000000002002 | asian/acura/3.5rl   |
| black | luxury     | 00000000000000002000 | asian/acura/3.5rl   |
| black | sports car | 00000000000000001996 | asian/acura/integra |
| black | sports car | 00000000000000001996 | asian/acura/integra |
| black | sports car | 00000000000000001993 | asian/acura/integra |
| black | sports car | 00000000000000001999 | asian/acura/integra |
| black | sports car | 00000000000000001994 | asian/acura/integra |
+-------+------------+----------------------+---------------------+
10 rows in set, 4245 hits, 15000 total docs (server: 3ms, total: 78ms)
    </pre>
  </li>
  
  <li>
    <p>Find all cars with color matching pattern "bl__" (4 characters
    only):</p>

    <pre>
SELECT color, category, year, makemodel
FROM   cars
WHERE  color like "bl__"
    </pre>

    <p><span class="emphasis"><em>Results:</em></span></p>

    <pre>
+-------+----------+----------------------+-----------------------------+
| color | category | year                 | makemodel                   |
+-------+----------+----------------------+-----------------------------+
| blue  | compact  | 00000000000000001993 | asian/acura/3.2tl           |
| blue  | compact  | 00000000000000001999 | asian/acura/tl              |
| blue  | compact  | 00000000000000001998 | asian/acura/tl              |
| blue  | compact  | 00000000000000001998 | asian/acura/tl              |
| blue  | compact  | 00000000000000001997 | asian/acura/tl              |
| blue  | compact  | 00000000000000001998 | asian/acura/vigor           |
| blue  | compact  | 00000000000000001999 | north american/eagle/2000   |
| blue  | sedan    | 00000000000000001993 | north american/eagle/vision |
| blue  | sedan    | 00000000000000002000 | north american/eagle/vision |
| blue  | sedan    | 00000000000000001995 | north american/eagle/vision |
+-------+----------+----------------------+-----------------------------+
10 rows in set, 1104 hits, 15000 total docs (server: 3ms, total: 59ms)
    </pre>
  </li>
</ol>


<h3>Queries with Full Text Search</h3>

<p>In the WHERE clause, you can add a condition for full text search,
which is called a (text) query. This condition is to find the documents
that contain matching text. You can use Lucene Query Syntax in the text
string that you search on.</p>

<ol class="orderedlist" type="1">
  <li>
    <p><span class="bold"><strong>Find all the cars that are tagged with
    "hybrid" and "navigation":</strong></span></p>

    <pre>
SELECT tags, makemodel
FROM   cars
WHERE  QUERY IS "hybrid AND navigation"
    </pre>

    <p><span class="bold"><strong>Results:</strong></span></p>

    <pre>
+-------------------------------------+----------------------------+
| tags                                | makemodel                  |
+-------------------------------------+----------------------------+
| hybrid,leather,moon-roof,navigation | asian/acura/tl             |
| favorite,hybrid,mp3,navigation      | asian/acura/tl             |
| favorite,hybrid,mp3,navigation      | asian/acura/3.2tl          |
| favorite,hybrid,mp3,navigation      | asian/acura/tl             |
| cool,hybrid,moon-roof,navigation    | asian/acura/tl             |
| cool,favorite,hybrid,navigation     | asian/acura/vigor          |
| automatic,cool,hybrid,navigation    | asian/acura/vigor          |
| cool,hybrid,moon-roof,navigation    | asian/acura/vigor          |
| cool,hybrid,moon-roof,navigation    | north american/asuna/se/gt |
| automatic,hybrid,leather,navigation | european/saab/900          |
+-------------------------------------+----------------------------+
10 rows in set, 778 hits, 15000 total docs (server: 186ms, total: 209ms)
    </pre>
  </li>

  <li>
    <p><span class="bold"><strong>A more complicated example:</strong></span></p>

    <pre>
SELECT color, tags, city
FROM   cars
WHERE  QUERY IS "(hybrid OR moon-roof) AND mp3 NOT cool NOT navigation"
AND    city in ("u.s.a./new york")
AND    color = "red"
    </pre>

    <p><span class="bold"><strong>Results:</strong></span></p>

    <pre>
+-------+-------------------------------+----------------------------+
| color | tags                          | city                       |
+-------+-------------------------------+----------------------------+
| red   | automatic,hybrid,mp3,reliable | u.s.a./new york/new york   |
| red   | hybrid,moon-roof,mp3,reliable | u.s.a./new york/buffalo    |
| red   | favorite,hybrid,mp3,reliable  | u.s.a./new york/syracuse   |
| red   | favorite,hybrid,mp3,reliable  | u.s.a./new york/buffalo    |
| red   | automatic,hybrid,mp3,reliable | u.s.a./new york/syracuse   |
| red   | favorite,hybrid,mp3,reliable  | u.s.a./new york/binghamton |
| red   | automatic,hybrid,mp3,reliable | u.s.a./new york/syracuse   |
+-------+-------------------------------+----------------------------+
7 rows in set, 7 hits, 15000 total docs (server: 17ms, total: 44ms)
    </pre>
  </li>
</ol>

<h3>Queries with GROUP BY</h3>

<ol>
  <li>
    <p>You can group the search results of a query by one facet, which
    can be a simple column or a facet built upon a group of columns. You
    can also specify how many hits you want
          to keep in each group (the default is 10).</p>

    <p><span class="bold"><strong>Find the first 10 groups of cars, with
    2 hits in each group:</strong></span></p>

    <pre>
SELECT   category, city, makemodel
FROM     cars
GROUP BY category TOP 2
    </pre>

    <p><span class="bold"><strong>Results:</strong></span></p>

    <pre>
========================================================================================
| category      | city                            | makemodel                          |
========================================================================================
| compact       | u.s.a./texas/houston            | asian/acura/tl                     |
| compact       | u.s.a./florida/tampa            | asian/acura/1.6el                  |
+---------------+---------------------------------+------------------------------------+
| exotic        | u.s.a./florida/tampa            | european/bentley/azure             |
| exotic        | u.s.a./california/san francisco | european/bentley/azure             |
+---------------+---------------------------------+------------------------------------+
| luxury        | u.s.a./florida/orlando          | asian/acura/3.5rl                  |
| luxury        | u.s.a./new york/rochester       | asian/acura/3.5rl                  |
+---------------+---------------------------------+------------------------------------+
| sports car    | u.s.a./california/sunnyvale     | asian/acura/integra                |
| sports car    | u.s.a./texas/austin             | asian/acura/integra                |
+---------------+---------------------------------+------------------------------------+
| sedan         | china/beijing                   | north american/eagle/vision        |
| sedan         | australia/perth                 | north american/eagle/vision        |
+---------------+---------------------------------+------------------------------------+
| suv           | china/shanghai                  | north american/ford/bronco         |
| suv           | u.s.a./california/sacramento    | north american/ford/bronco         |
+---------------+---------------------------------+------------------------------------+
| van           | u.s.a./florida/palm beach       | north american/ford/club wagon     |
| van           | u.s.a./new york/albany          | north american/ford/club wagon     |
+---------------+---------------------------------+------------------------------------+
| truck         | u.s.a./utah/provo               | asian/mazda/b-series               |
| truck         | australia/melbourn              | asian/isuzu/pickup                 |
+---------------+---------------------------------+------------------------------------+
| station wagon | u.s.a./texas/dallas             | north american/saturn/sw           |
| station wagon | u.s.a./california/san jose      | north american/saturn/sw           |
+---------------+---------------------------------+------------------------------------+
| mini-van      | u.s.a./texas/austin             | north american/chevrolet/astro van |
| mini-van      | u.s.a./california/san jose      | north american/chevrolet/astro van |
+---------------+---------------------------------+------------------------------------+
========================================================================================
10 groups in set, 15000 hits, 15000 total docs (server: 55ms, total:130ms)
    </pre>
  </li>

  <li>
    <p><span class="bold"><strong>Find the numbers of cars in different
    categories:</strong></span></p>

    <pre>
SELECT   category, _grouphitscount
FROM     cars
GROUP BY category top 1
    </pre>

    <p><span class="bold"><strong>Results:</strong></span></p>

    <pre>
+---------------+----------------+
| category      | _grouphitscount |
+---------------+-----------------+
| compact       | 4169            |
| exotic        | 1902            |
| luxury        | 2735            |
| sports car    | 1494            |
| sedan         | 990             |
| suv           | 1449            |
| van           | 168             |
| truck         | 611             |
| station wagon | 186             |
| mini-van      | 869             |
+---------------+-----------------+
10 rows in set, 15000 hits, 15000 total docs (server: 3ms, total: 38ms)
    </pre>
  </li>
</ol>


<h3>Getting Facet Information Using BROWSE BY Clause</h3>

<p>BQL is designed to support faceted search, so we have to make it
possible to get facet information along with the search results. This
can be done using the Browse By clause, where you can specify one or
more facets for which you want to get the facet count information. For
each facet in the BROWSE BY clause, you can optionally include</p>

<ul>
  <li>
    <p>whether the selection is expanded (default false)</p>
  </li>
  <li>
    <p>the minimum number of hit counts (default 1)</p>
  </li>
  <li>
    <p>the maximum number of hit counts (default 10)</p>
  </li>
  <li>
    <p>facet ordering method ("hits" or "value") (default "hits")</p>
  </li>
</ul>

<p>Here is an example:</p>

<p><span class="bold"><strong>Query:</strong></span></p>

<pre>
SELECT    color, year, tags, price
FROM      cars
WHERE     QUERY IS "cool"
AND       tags CONTAINS ALL ("cool", "hybrid") EXCEPT ("favorite")
AND       color in ("red")
ORDER BY  price desc
LIMIT     0,10
BROWSE BY color(true, 1, 10, hits), year(true, 1, 10, value), price
</pre>

<p><span class="bold"><strong>Results:</strong></span></p>

<pre>
+-------+----------------------+----------------------------------+-------------------------+
| color | year                 | tags                             | price                   |
+-------+----------------------+----------------------------------+-------------------------+
| red   | 00000000000000002000 | cool,hybrid,moon-roof,navigation | 00000000000000014500.00 |
| red   | 00000000000000001993 | cool,hybrid,moon-roof,navigation | 00000000000000014400.00 |
| red   | 00000000000000002002 | automatic,cool,hybrid,navigation | 00000000000000014200.00 |
| red   | 00000000000000001998 | automatic,cool,hybrid,navigation | 00000000000000012100.00 |
| red   | 00000000000000002002 | automatic,cool,hybrid,reliable   | 00000000000000011500.00 |
| red   | 00000000000000002002 | automatic,cool,hybrid,reliable   | 00000000000000011400.00 |
| red   | 00000000000000001998 | automatic,cool,hybrid,reliable   | 00000000000000011400.00 |
| red   | 00000000000000001996 | automatic,cool,hybrid,reliable   | 00000000000000011200.00 |
| red   | 00000000000000001999 | automatic,cool,hybrid,reliable   | 00000000000000011100.00 |
| red   | 00000000000000002001 | cool,hybrid,moon-roof,reliable   | 00000000000000010500.00 |
+-------+----------------------+----------------------------------+-------------------------+
10 rows in set, 59 hits, 15000 total docs (server: 337ms, total: 372ms)
+-------------+
| color       |
+-------------+
| white  (73) |
| yellow (73) |
| blue   (62) |
| silver (61) |
| red    (59) |
| green  (58) |
| gold   (53) |
| black  (52) |
+-------------+
+-----------------------+
| price                 |
+-----------------------+
| [6800 TO 9900]   (27) |
| [* TO 6700]      (21) |
| [10000 TO 13100] (8)  |
| [13200 TO 17300] (3)  |
+-----------------------+
+---------------------+
| year                |
+---------------------+
| [1993 TO 1994] (16) |
| [1995 TO 1996] (13) |
| [1997 TO 1998] (10) |
| [1999 TO 2000] (9)  |
| [2001 TO 2002] (11) |
+---------------------+</pre>

<h3>Queries with Run-Time Facet Handler Initialization Parameters</h3>

<p>In a faceted search system, a run-time facet handler usually requires
initialization parameter(s) to be provided at search time for each
query. For example, in a search system that searches LinkedIn shares or
Twitter tweets, one or more run-time facets usually require the searcher
to provide his/her user Id (or user name) and the time when the search
is performed.</p>

<p>One run-time facet may need multiple initialization parameters, each
of which has a different name and/or a different data type. These
parameters can be specified in the SELECT statement using the GIVEN
FACET PARAM clause. Every parameter is specified in the clause as a
4-tuple,
(<span class="emphasis"><em>facet-name</em></span>, <span class="emphasis"><em>param-name</em></span>,
<span class="emphasis"><em>param-type</em></span>,
<span class="emphasis"><em>param-value</em></span>).</p>

<ol>
  <li>
    <p><span class="bold"><strong>On a search system for LinkedIn
    shares, find recent updates from member 12345678 himself (i.e. value
    0 for the Network facet) and all his first degree connections
    (i.e. value 1 for the Network facet) in US: </strong></span></p>

    <pre>
SELECT uid, Network, userid, country
FROM   shares
WHERE  country = "us"
AND    Network in (0, 1)
GIVEN FACET PARAM (Network, "member_id", int, 12345678)
    </pre>

    <p><span class="bold"><strong>Results:</strong></span></p>

    <pre>
+---------------------+---------+----------------------+---------+
| uid                 | Network | userid               | country |
+---------------------+---------+----------------------+---------+
| 5527797854963249152 | 0       | 00000000000012345678 | us      |
| 5527805402646839296 | 1       | 00000000000042593551 | us      |
| 5527816561408086016 | 0       | 00000000000012345678 | us      |
| 5527825082430267392 | 1       | 00000000000022593551 | us      |
| 5527829323551084544 | 0       | 00000000000012345678 | us      |
| 5527848889647902720 | 1       | 00000000000004730909 | us      |
| 5527853965330358272 | 1       | 00000000000004730909 | us      |
| 5527884781573898240 | 1       | 00000000000026325826 | us      |
| 5527487070454427648 | 0       | 00000000000012345678 | us      |
| 5527488521884930048 | 0       | 00000000000012345678 | us      |
+---------------------+---------+----------------------+---------+
10 rows in set, 14 hits, 10749644 total docs (server: 432ms, total: 472ms)
    </pre>
